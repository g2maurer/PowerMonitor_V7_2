

/////////////////////////////////////////
//
//
//
void loadLogConfig(void)
{
#ifdef DELETE_LOG_CONFIG
  deleteFileSPIFFS(fnLogConfig);
  //deleteFileSPIFFS(fnEventLog);
  //deleteFileSPIFFS(fnIntervalLog);
#endif
  if (!existsFileSPIFFS(fnLogConfig))
  {
    Serial.println("Creating Log configuration file");
    LogConfig.enabled = false;
    LogConfig.eventLog = false;
    LogConfig.intervalLog = false;
    LogConfig.state = LOG_IDLE;
    LogConfig.timeInterval = 10;
    for(int i = 1; i < 5; i++)
    {
      LogConfig.eLogCT[i] = false;      // CTn Event log enable/disable 
      LogConfig.ampCT[i] = 0.5;         // CTn event trigger, change in amperage
    }

    LogConfig.logTemperature = false;
    
    wrtFileSPIFFS(fnLogConfig, (char *)&LogConfig, sizeof(LogConfig));
  }

  Serial.println("Reading Log configuration file");
  if (rdFileSPIFFS(fnLogConfig, (char *)&LogConfig, sizeof(LogConfig)))
  {

  }
}

SWITCH_STRUCT eventSw = {
  0,
  true,         // bool horiz; 
  110,           // int xPos;       
  140,          // int yPos;      
  100,           // int xSize;
  35,           // int ySize;
  15,           // int swRadius;
  SW_TXT_BOTH,  // int textPos;   
};

SWITCH_STRUCT intervalSw = {
  0,
  true,         // bool horiz;     
  110,           // int xPos;       
  140, //295,          // int yPos;     
  100,           // int xSize;
  35,           // int ySize;
  15,           // int swRadius;
  SW_TXT_BOTH,  // int textPos;    
};

/////////////////////////////////////////
//
//
//
void displayLogMenu(void)
{
  pushTA();
  drawPageHeader("Log Settings","", false);
  setGfxFont(FSS12);
  drawBtn5("Event");
  myTFT.fillRoundRect(88, 89, 220, 67, 10, TFT_BLACK);
  myTFT.drawRoundRect(88, 89, 220, 67, 10, TFT_LIGHTGREY);
  myTFT.drawString("Event Log", 200, 105); 
  myTFT.drawString("Settings", 200, 135); 
  drawBtn9("Interval");
  myTFT.fillRoundRect(88, 167, 220, 67, 10, TFT_BLACK);
  myTFT.drawRoundRect(88, 167, 220, 67, 10, TFT_LIGHTGREY);
  myTFT.drawString("Interval Log", 200, 183);  
  myTFT.drawString("Settings", 200, 213);
  drawBtn13("Start");
  myTFT.fillRoundRect(88, 245, 220, 67, 10, TFT_BLACK);
  myTFT.drawRoundRect(88, 245, 220, 67, 10, TFT_LIGHTGREY);
  myTFT.drawString("Start", 200, 261);  
  myTFT.drawString("Logging", 200, 291); 
  drawBtn17("Stop");
  myTFT.fillRoundRect(88, 323, 220, 67, 10, TFT_BLACK);
  myTFT.drawRoundRect(88, 323, 220, 67, 10, TFT_LIGHTGREY);
  myTFT.drawString("Stop", 200, 339);  
  myTFT.drawString("Logging", 200, 369); 
  drawBtnExit();
  popTA();
}

//////////////////////////////
//
//
//
void displayEventMenu(void)
{
  char eBuf[32];
  pushTA();
  drawPageHeader("Event Log Settings","", false);
  setGfxFont(FSS12);
  drawBtn5("CT-1");
  myTFT.fillRoundRect(88, 89, 220, 67, 10, TFT_BLACK);
  myTFT.drawRoundRect(88, 89, 220, 67, 10, TFT_LIGHTGREY);
  myTFT.drawString("CT-1 Event Log", 200, 105);  
  myTFT.drawString("Settings", 200, 135);
  
  drawBtn9("CT-2");
  myTFT.fillRoundRect(88, 167, 220, 67, 10, TFT_BLACK);
  myTFT.drawRoundRect(88, 167, 220, 67, 10, TFT_LIGHTGREY);
  myTFT.drawString("CT-2 Event Log", 200, 183);  
  myTFT.drawString("Settings", 200, 213);
  
  drawBtn13("CT-3");
  myTFT.fillRoundRect(88, 245, 220, 67, 10, TFT_BLACK);
  myTFT.drawRoundRect(88, 245, 220, 67, 10, TFT_LIGHTGREY);
  myTFT.drawString("CT-3 Event Log", 200, 261);  
  myTFT.drawString("Settings", 200, 291);
  
  drawBtn17("CT-4");
  myTFT.fillRoundRect(88, 323, 220, 67, 10, TFT_BLACK);
  myTFT.drawRoundRect(88, 323, 220, 67, 10, TFT_LIGHTGREY);
  myTFT.drawString("CT-4 Event Log", 200, 339);  
  myTFT.drawString("Settings", 200, 369);
      
  myTFT.drawFastHLine(0,395,319,TFT_YELLOW);
  drawBtnExit();
  popTA();
}

/////////////////////////////////
//
//    Display settings for CTn Event Logging
//        eLogCTn 1, 2, 3, or 4
//
void displayCTneLog(void)
{
  char eBuf[32];
  pushTA();
  sprintf(eBuf,"CT%d Log Settings", eLogCTn);
  drawPageHeader(eBuf,"", false);
  // Draw enable/disable switch
  setGfxFont(FSS12);
  myTFT.setTextDatum(TC_DATUM);
  myTFT.drawString("Event Log", 160, 100);
  drawSwitch(eventSw, LogConfig.eLogCT[eLogCTn]);
  if(LogConfig.eLogCT[eLogCTn])      // if enabled
  {
    myTFT.drawFastHLine(0,200,319,TFT_YELLOW);
    myTFT.drawString("Log entry generated by", 160, 225);
    myTFT.drawString("change in current", 160, 255);
    myTFT.drawString("equal or greater than:", 160, 285);
    sprintf(eBuf,"%0.1f Amps",LogConfig.ampCT[eLogCTn]); 
    myTFT.setTextColor(TFT_GREEN);
    setGfxFont(FSSB18);
    myTFT.drawString(eBuf, 160, 330);
  }
  myTFT.drawFastHLine(0,395,319,TFT_YELLOW);
  drawBtnExit();
  popTA();
}



///////////////////////////////
//
//
//
void displayIntervalMenu(void)
{
  char iBuf[32];
  pushTA();
  drawPageHeader("Interval Log Settings","", false);
  // Draw enable/disable switch
  setGfxFont(FSS12);
  myTFT.setTextDatum(TC_DATUM);
  myTFT.drawString("Interval Log", 160, 100);
  drawSwitch(intervalSw, LogConfig.intervalLog);
  if(LogConfig.intervalLog)
  {
    myTFT.drawFastHLine(0,200,319,TFT_YELLOW);
    myTFT.drawString("Interval Trigger", 160, 225);
    myTFT.drawString("log entry", 160, 255);
    myTFT.drawString("generated every:", 160, 285);
    sprintf(iBuf,"%d seconds",LogConfig.timeInterval);
    myTFT.setTextColor(TFT_GREEN);
    setGfxFont(FSSB18);
    myTFT.drawString(iBuf, 160, 330);
  }
  myTFT.drawFastHLine(0,395,319,TFT_YELLOW);
  drawBtnExit();
  popTA();
}

////////////////////////////////////////////////////
//
//
//
void displayIntervalKeypad(void)
{
  char vbuf[16];
  pushTA();
  drawKeypad( &iKp);
  sprintf(vbuf, "%d Seconds", tmpIntValue);
  displayValueOnKeypad(&iKp, vbuf);
  popTA();
}

////////////////////////////////////////////////////
//
//
//
void displayEventKeypad(void)
{
  char vbuf[16];
  pushTA();
  drawKeypad( &iKp);
  sprintf(vbuf, "%0.1f Amps", float(tmpEventValue) / 10.0);
  displayValueOnKeypad(&iKp, vbuf);
  popTA();
}

//////////////////////////////////////////////
//
//
//
void processLogMenu(int button)
{
  bool refresh = false;
  switch(button)
  {
    case 13:        // Start
      LogConfig.state = LOG_START;
      refresh = true;
      break;
    case 17:        // Stop
      LogConfig.state = LOG_STOP;
      refresh = true;
      break;
    case 24:        // Exit & Save
      LogConfig.eventLog = false;
      for( int i = 1; i < 5; i++)
      {
        if(LogConfig.eLogCT[i]) LogConfig.eventLog = true;
      }
      if(changedLogConfig)
      {
        Serial.println("Log configuration has changed - Saving");
        wrtFileSPIFFS(fnLogConfig, (char *)&LogConfig, sizeof(LogConfig));
      }
      popMenu();    // Exit & Save
      break;
    case 5:         // Event Log Settings
      pushMenu(ELOG_MENU);
      break;
    case 9:        // Interval Log Settings
      pushMenu(ILOG_MENU);
      break;
  }
  if(refresh) 
  {
    changedLogConfig = true;
    displayLogMenu();
  }
}

///////////////////////////////////
//
//
//
void processEventMenu(int button)
{
   bool refresh = false;
  switch(button)
  {
    case 5:
      eLogCTn = 1;
      pushMenu(ELOG_CT_MENU);
      break;
    case 9:
      eLogCTn = 2;
      pushMenu(ELOG_CT_MENU);
      break;
    case 13:
      eLogCTn = 3;
      pushMenu(ELOG_CT_MENU);
      break;
    case 17:
      eLogCTn = 4;
      pushMenu(ELOG_CT_MENU);
      break;
    case 24:
      popMenu();
      break;
  }
  if(refresh) 
  {
    changedLogConfig = true;
    displayEventMenu();
  }
}

///////////////////////////////////
//
//
//
void processEventCTMenu(int button)
{
  //Serial.println("processEventCTMenu");
  bool refresh = false;
  switch(swTouchChk(eventSw))
  {
    case SW_NONE:
      break;
    case SW_LEFT:
      LogConfig.eLogCT[eLogCTn] = false;
      refresh = true;
      break;
    case SW_RIGHT:
      LogConfig.eLogCT[eLogCTn] = true;
      refresh = true;
      break;
  }
  //Serial.printf("x = %d, y = %d\n\r", touchData.x, touchData.y);
  if( (touchData.x > 100) && (touchData.x < 220))
  {
    if(( touchData.y > 320) && (touchData.y < 370))
    {
      tmpEventValue = (int)(LogConfig.ampCT[eLogCTn] * 10.0);
      //Serial.printf("ampCT = %0.1f\n\r",LogConfig.ampCT[eLogCTn] * 10.0); 
      //Serial.printf("eLogCTn = %d\n\r", eLogCTn);
      pushMenu(ELOG_KPAD);
    }
  }
  switch(button)
  {
    case 24:        // Exit
      popMenu();
      break;
  }  
  if(refresh) 
  {
    changedLogConfig = true;
    displayCTneLog();
  }
}
   
///////////////////////////////////////
//
//
//
void processIntervalMenu(int button)
{
  bool refresh = false;
  switch(swTouchChk(intervalSw))
  {
    case SW_NONE:
      break;
    case SW_LEFT:
      LogConfig.intervalLog = false;
      refresh = true;
      break;
    case SW_RIGHT:
      LogConfig.intervalLog = true;
      refresh = true;
      break;
  }
  if( (touchData.x > 100) && (touchData.x < 220))
  {
    if(( touchData.y > 320) && (touchData.y < 370))
    {
      tmpIntValue = LogConfig.timeInterval;
      pushMenu(ILOG_KPAD);
    }
  }
  switch(button)
  {
    case 24:        // Exit
      popMenu();
      break;
  }  
  if(refresh) 
  {
    changedLogConfig = true;
    displayIntervalMenu();
  }
}

//////////////////////////////////
//
//
//
void processIntervalKeypad(void)
{
  char vbuf[16];
  //Serial.println("processIntervalKeypad");
  int key = processKpTouch(&iKp);
  //Serial.printf("Key = %d\n\r", key);
  if(key == 11) 
  {
    if( (tmpIntValue > 10) && (tmpIntValue < 1000) )
    {
      LogConfig.timeInterval = tmpIntValue;
      changedLogConfig = true;
    }
    popMenu();
  }
  else
  {
    if(key == 10) tmpIntValue = tmpIntValue / 10; // deletes right-most digit
    else if((key >= 0) && (key < 10))
    {
      tmpIntValue = tmpIntValue * 10 + key;
    }
    //Serial.printf("Value = %d\n\r", tmpIntValue);
    sprintf(vbuf, "%d Seconds", tmpIntValue);
    displayValueOnKeypad(&iKp, vbuf);
    // redisplay value
  }
}

//////////////////////////////////
//
//
//
void processEventKeypad(void)
{
  char vbuf[16];
  //Serial.println("processEventKeypad");
  int key = processKpTouch(&iKp);
  //Serial.printf("Key = %d\n\r", key);
  if(key == 11) 
  {
    if( (tmpEventValue >= 1) && (tmpEventValue < 1000) )
    {
      LogConfig.ampCT[eLogCTn] = float(tmpEventValue) / 10.0;
      changedLogConfig = true;
    }
    popMenu();
  }
  else
  {
    if( (key == 10) && (tmpEventValue > 0) ) 
    {
      tmpEventValue = tmpEventValue / 10; // deletes right-most digit
      //if(tmpEventValue < 1) tmpEventValue = 0;
    }
    else if((key >= 0) && (key < 10))
    {
      tmpEventValue = tmpEventValue * 10 + key;
    }
    //Serial.printf("Value = %0.1f\n\r", (float)tmpEventValue / 10.0);
    sprintf(vbuf, "%0.1f Amps", (float)tmpEventValue / 10.0);
    displayValueOnKeypad(&iKp, vbuf);
    // redisplay value
  }
}


/////////////////////////////////////////////////////////
//
//
//
//
void logging(void)
{
  switch(LogConfig.state)
  {
    case LOG_IDLE:
      break;
    case LOG_START:
      Serial.println("START Logging");
      if((LogConfig.eventLog) && (LogConfig.intervalLog))
      {
        LogConfig.state = LOG_EVENT_N_INTERVAL;
        logIntervalTimer = LogConfig.timeInterval;
        // Build Filenames
        strftime(fnEvent, sizeof(fnEvent), "/E%y%m%d.csv", timeinfo);
        strftime(fnInterval, sizeof(fnInterval), "/I%y%m%d.csv", timeinfo);
      }
      else if(LogConfig.eventLog)
      {
        LogConfig.state = LOG_EVENT;
        // Build Filename
        strftime(fnEvent, sizeof(fnEvent), "/E%y%m%d.csv", timeinfo);
        Serial.println(fnEvent);
      }
      else if(LogConfig.intervalLog)
      {
        LogConfig.state = LOG_INTERVAL;
        logIntervalTimer = LogConfig.timeInterval;
        // Build Filename
        strftime(fnInterval, sizeof(fnInterval), "/I%y%m%d.csv", timeinfo);
        Serial.println(fnInterval);
      }
#ifdef SD_SUPPORT
      if(!existsFile(SD, fnInterval))
      {
        Serial.print("Creating file: ");
        Serial.println(fnInterval);
        writeFile(SD, fnInterval, "Time, CT1, CT2, CT3, CT4\r");
      }
      if(!existsFile(SD, fnEvent))
      {
        Serial.print("Creating file: ");
        Serial.println(fnEvent);
        writeFile(SD, fnEvent, "Time, CT1, CT2, CT3, CT4\r");
      }
#endif
      break;
    case LOG_STOP:
      Serial.println("STOP Logging");
      LogConfig.state = LOG_IDLE;
      break;
    case LOG_EVENT:
      eventLogging();
      break;
    case LOG_INTERVAL:
      intervalLogging();
      break;
    case LOG_EVENT_N_INTERVAL:
      eventLogging();
      intervalLogging();
      break;
  }
}

////////////////////////////////////////////////////////////
//
//  Generate log data on every event (checks once a second)
//
void eventLogging(void)
{
  boolean logIt = false;
  if( LogConfig.eLogCT[1] )
  {
    if( abs(chanData1.load - chanData1.prevLoad) >= LogConfig.ampCT[1])
    {
      logIt = true;
      chanData1.prevLoad = chanData1.load;
    }
  }
  if( LogConfig.eLogCT[2] )
  {
    if( abs(chanData2.load - chanData2.prevLoad) >= LogConfig.ampCT[2]) 
    {
      logIt = true;
      chanData2.prevLoad = chanData2.load;
    }
  }
  if( LogConfig.eLogCT[3] )
  {
    if( abs(chanData3.load - chanData3.prevLoad) >= LogConfig.ampCT[3])
    {
      logIt = true;
      chanData3.prevLoad = chanData3.load;
    }
  }
  if( LogConfig.eLogCT[4] )
  { 
    if( abs(chanData4.load - chanData4.prevLoad) >= LogConfig.ampCT[4])
    {
      logIt = true;
      chanData4.prevLoad = chanData4.load;
    }
  }
  if(logIt)
  {
    // generate log and append to file
    //
    Update_timeinfo();
    strftime(timeTxt, sizeof(timeTxt), "%H:%M:%S", timeinfo);
    sprintf(logText, "%s, %3.2f, %3.2f, %3.2f, %3.2f \r", timeTxt,
              chanData1.Irms, chanData2.Irms, chanData3.Irms, chanData4.Irms);
    Serial.println(logText);
#ifdef SD_SUPPORT
    appendFile(SD, fnEventLog, logText);
#endif
  }
}

////////////////////////////////////////////////////////////
//
//  Generate log data every time interval (seconds)
//
void intervalLogging(void)
{
  if(logIntervalTimer != 0)
  {
    logIntervalTimer--;
  }
  if(logIntervalTimer == 0)
  {
    logIntervalTimer = LogConfig.timeInterval;
    // generate log and append to file
    //
    Update_timeinfo();
    strftime(timeTxt, sizeof(timeTxt), "%H:%M:%S", timeinfo);
    sprintf(logText, "%s, %3.2f, %3.2f, %3.2f, %3.2f \r", timeTxt,
              chanData1.Irms, chanData2.Irms, chanData3.Irms, chanData4.Irms);
    Serial.println(logText);
#ifdef SD_SUPPORT
    appendFile(SD, fnInterval, logText);
#endif
  }
  
}
